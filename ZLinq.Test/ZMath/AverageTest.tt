<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)ZLinq.TTHelp\bin\$(Configuration)\ZLinq.TTHelp.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="ZLinq.TTHelp" #>
<#@ output extension=".cs" #>

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZLinq.Test.Helpers;


// ReSharper disable RedundantCast
namespace ZLinq.Test.ZMath
{
    [TestClass]
    public class Average
    {            
        private const double Tolerance = 0.0000001;
                    
    <#foreach (var type in TT.WithNullables(TT.NumberTypes)) { #>

        #region <#= type #>             
        <# foreach (string sourceType in TT.StandardLists) {
            string name = TT.GetCollectionName(sourceType);
            string typeName = TT.GetNullableName(type);
            bool isInteger = !TT.IsFloat(type);
            string trimmedType = type.TrimEnd('?');
            string expectedVal = isInteger ? trimmedType + ".MaxValue/10*9" : "short.MaxValue";
         #>    

         
        [TestMethod]
        public void TestAverage<#= typeName #><#= name #>NullOrEmpty()
        {        
            <#= sourceType.Replace("T", type) #> nullSource = null;

            try
            {
                ZEnumerable.Average(nullSource);                
                Assert.Fail();
            }
            catch (ArgumentNullException)
            {
                
            }

            <#= sourceType.Replace("T", type) #> emptySource = new <#= type #>[0].To<#= name #>();
            try
            {
                ZEnumerable.Average(emptySource);                
                Assert.Fail();
            }
            catch (InvalidOperationException)
            {
                
            }
        }

        [TestMethod]
        public void TestAverage<#= typeName #><#= name #>MapNullOrEmpty()
        {
            var source = Enumerable.Range(1, 1).Select(arg => new KeyValuePair<<#= type #>,<#= type #>>((<#= type #>) arg, (<#= type #>) arg)).To<#= name #>();
            Func<KeyValuePair<<#= type #>, <#= type #>>, <#= type #>> nullMap = null;
            try
            {
                ZEnumerable.Average(source, nullMap);                
                Assert.Fail();
            }
            catch (ArgumentNullException)
            {
                
            }

            var emptySource = source.Take(0).To<#= name #>();
            try
            {
                ZEnumerable.Average(emptySource, nullMap);                
                Assert.Fail();
            }
            catch (ArgumentNullException)
            {
                
            }
            try
            {
                ZEnumerable.Average(emptySource, x => x.Key);                
                Assert.Fail();
            }
            catch (InvalidOperationException)
            {
                
            }
        }
         
        <# foreach(int i in TT.TestSizes) { #>

        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #><#= i #>()
        {            
            const <#= trimmedType #> expected = <#= expectedVal #>;
            var source = Enumerable.Repeat((<#= type #>) expected, <#= i #>).To<#= name #>();

            double result = ZEnumerable.Average(source);

            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }

        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #><#= i #>Map()
        {
            const <#= trimmedType #> expected = <#= expectedVal #>;
            var source = Enumerable.Repeat(new { X = expected}, <#= i #>).To<#= name #>();

            double result = ZEnumerable.Average(source, arg => (<#= type #>) arg.X);
            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }

        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #><#= i #>Min()
        {            
            const <#= trimmedType #> expected = <#= 1 #>;
            var source = Enumerable.Repeat((<#= type #>) expected, <#= i #>).To<#= name #>();

            double result = ZEnumerable.Average(source);

            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }

        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #><#= i #>MapMin()
        {
            const <#= trimmedType #> expected = <#= 1 #>;
            var source = Enumerable.Repeat(new { X = expected}, <#= i #>).To<#= name #>();

            double result = ZEnumerable.Average(source, arg => (<#= type #>) arg.X);
            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }
          
        <# } #>

        <# if (isInteger) { #>        
        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #>NoOverflow()
        {
            const <#= trimmedType #> expected = <#= trimmedType #>.MaxValue;
            var source = Enumerable.Repeat((<#= type #>) expected, 2).To<#= name #>();
            double result = ZEnumerable.Average(source);
            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }
        
        [TestMethod]
        public void TestAverage<#= typeName #><#= TT.GetCollectionName(sourceType) #>MapNoOverflow()
        {    
            const <#= trimmedType #> expected = <#= trimmedType #>.MaxValue;
            var source =  Enumerable.Repeat(new { X = (<#= type #>) expected} , 2).To<#= name #>();
            double result = ZEnumerable.Average(source, arg => arg.X);
            <#= TT.AssertFloatsRelative("result", "expected", "Tolerance") #>
        }
        <# } #>
        <# } #>
        
        #endregion
    <# } #>  
    }
}